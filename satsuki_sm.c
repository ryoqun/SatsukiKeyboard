/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : satsuki.sm
 */

#include "engine.h"
#include "satsuki_sm.h"
#include "statemap.h"

#define getOwner(fsm) (fsm)->_owner

#define ENTRY_STATE(state) \
    if ((state)->Entry != NULL) { \
        (state)->Entry(fsm); \
    }

#define EXIT_STATE(state) \
    if ((state)->Exit != NULL) { \
        (state)->Exit(fsm); \
    }

static void TurnstileState_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    getState(fsm)->Default(fsm);
}

static void TurnstileState_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    getState(fsm)->Default(fsm);
}

static void TurnstileState_Default(struct satsukiContext *const fsm)
{
    if (getDebugFlag(fsm) != 0) {
        TRACE("TRANSITION   : %s.%s\n", getName(getState(fsm)), getTransition(fsm));
    }
    State_Default(fsm);
}

#define MainMap_Normal_keydown TurnstileState_keydown
#define MainMap_Normal_keyup TurnstileState_keyup
#define MainMap_Normal_Default TurnstileState_Default
#define MainMap_Shift_keydown TurnstileState_keydown
#define MainMap_Shift_keyup TurnstileState_keyup
#define MainMap_Shift_Default TurnstileState_Default
#define MainMap_Tenkey_keydown TurnstileState_keydown
#define MainMap_Tenkey_keyup TurnstileState_keyup
#define MainMap_Tenkey_Default TurnstileState_Default
#define MainMap_PostSpace_keydown TurnstileState_keydown
#define MainMap_PostSpace_keyup TurnstileState_keyup
#define MainMap_PostSpace_Default TurnstileState_Default
#define MainMap_NestedSpace_keydown TurnstileState_keydown
#define MainMap_NestedSpace_keyup TurnstileState_keyup
#define MainMap_NestedSpace_Default TurnstileState_Default
#define MainMap_NestedZKeyControl_keydown TurnstileState_keydown
#define MainMap_NestedZKeyControl_keyup TurnstileState_keyup
#define MainMap_NestedZKeyControl_Default TurnstileState_Default
#define MainMap_NestedSlashControl_keydown TurnstileState_keydown
#define MainMap_NestedSlashControl_keyup TurnstileState_keyup
#define MainMap_NestedSlashControl_Default TurnstileState_Default
#define MainMap_PreSpace_keydown TurnstileState_keydown
#define MainMap_PreSpace_keyup TurnstileState_keyup
#define MainMap_PreSpace_Default TurnstileState_Default
#define MainMap_Space_keydown TurnstileState_keydown
#define MainMap_Space_keyup TurnstileState_keyup
#define MainMap_Space_Default TurnstileState_Default
#define MainMap_PreZKeyControl_keydown TurnstileState_keydown
#define MainMap_PreZKeyControl_keyup TurnstileState_keyup
#define MainMap_PreZKeyControl_Default TurnstileState_Default
#define MainMap_PreSlashControl_keydown TurnstileState_keydown
#define MainMap_PreSlashControl_keyup TurnstileState_keyup
#define MainMap_PreSlashControl_Default TurnstileState_Default
#define MainMap_SemiZKeyControl_keydown TurnstileState_keydown
#define MainMap_SemiZKeyControl_keyup TurnstileState_keyup
#define MainMap_SemiZKeyControl_Default TurnstileState_Default
#define MainMap_SemiSlashControl_keydown TurnstileState_keydown
#define MainMap_SemiSlashControl_keyup TurnstileState_keyup
#define MainMap_SemiSlashControl_Default TurnstileState_Default
#define MainMap_ZKeyControl_keydown TurnstileState_keydown
#define MainMap_ZKeyControl_keyup TurnstileState_keyup
#define MainMap_ZKeyControl_Default TurnstileState_Default
#define MainMap_SlashControl_keydown TurnstileState_keydown
#define MainMap_SlashControl_keyup TurnstileState_keyup
#define MainMap_SlashControl_Default TurnstileState_Default
#define MainMap_DefaultState_keydown TurnstileState_keydown
#define MainMap_DefaultState_keyup TurnstileState_keyup

#undef MainMap_Normal_keydown
static void MainMap_Normal_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Normal)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_shift ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        pushState(fsm, &MainMap_Shift);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_tenkey ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        pushState(fsm, &MainMap_Tenkey);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Normal_keyup
static void MainMap_Normal_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Normal)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_Normal.keyup(event)\n");
    }
    clearState(fsm);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_Normal.keyup(event)\n");
    }
    setState(fsm, EndStateName);
}

const struct TurnstileState MainMap_Normal = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_Normal_keydown,
    MainMap_Normal_keyup,
    MainMap_Normal_Default,
    0, "MainMap_Normal"
};

void MainMap_Shift_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_shift_mode(ctxt, True);
}

void MainMap_Shift_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_shift_mode(ctxt, False);
}

#undef MainMap_Shift_keydown
static void MainMap_Shift_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Shift)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Shift.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Shift.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_tenkey ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Shift.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Shift.keydown(event)\n");
        }
        pushState(fsm, &MainMap_Tenkey);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Shift.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Shift.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Shift_keyup
static void MainMap_Shift_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Shift)\n");
    }
    if ( event.is_shift ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Shift.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Shift.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Shift.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Shift.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Shift = {
    MainMap_Shift_Entry,
    MainMap_Shift_Exit,
    MainMap_Shift_keydown,
    MainMap_Shift_keyup,
    MainMap_Shift_Default,
    1, "MainMap_Shift"
};

void MainMap_Tenkey_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_tenkey_mode(ctxt, True);
}

void MainMap_Tenkey_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_tenkey_mode(ctxt, False);
}

#undef MainMap_Tenkey_keydown
static void MainMap_Tenkey_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Tenkey)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_Tenkey.keydown(event)\n");
    }
    clearState(fsm);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_Tenkey.keydown(event)\n");
    }
    setState(fsm, EndStateName);
}

#undef MainMap_Tenkey_keyup
static void MainMap_Tenkey_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Tenkey)\n");
    }
    if ( event.is_tenkey ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Tenkey.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Tenkey.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Tenkey.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Tenkey.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Tenkey = {
    MainMap_Tenkey_Entry,
    MainMap_Tenkey_Exit,
    MainMap_Tenkey_keydown,
    MainMap_Tenkey_keyup,
    MainMap_Tenkey_Default,
    2, "MainMap_Tenkey"
};

#undef MainMap_PostSpace_keydown
static void MainMap_PostSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PostSpace)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_PostSpace.keydown(event)\n");
    }
    clearState(fsm);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_PostSpace.keydown(event)\n");
    }
    setState(fsm, EndStateName);
}

#undef MainMap_PostSpace_keyup
static void MainMap_PostSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PostSpace)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PostSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PostSpace.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PostSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PostSpace.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_PostSpace = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PostSpace_keydown,
    MainMap_PostSpace_keyup,
    MainMap_PostSpace_Default,
    3, "MainMap_PostSpace"
};

void MainMap_NestedSpace_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, True);
}

void MainMap_NestedSpace_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, False);
}

#undef MainMap_NestedSpace_keydown
static void MainMap_NestedSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedSpace)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSpace.keydown(event)\n");
    }
    clearState(fsm);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSpace.keydown(event)\n");
    }
    setState(fsm, EndStateName);
}

#undef MainMap_NestedSpace_keyup
static void MainMap_NestedSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedSpace)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSpace.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSpace.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedSpace = {
    MainMap_NestedSpace_Entry,
    MainMap_NestedSpace_Exit,
    MainMap_NestedSpace_keydown,
    MainMap_NestedSpace_keyup,
    MainMap_NestedSpace_Default,
    4, "MainMap_NestedSpace"
};

void MainMap_NestedZKeyControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_NestedZKeyControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_NestedZKeyControl_keydown
static void MainMap_NestedZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedZKeyControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedZKeyControl.keydown(event)\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedZKeyControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedZKeyControl.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_NestedZKeyControl_keyup
static void MainMap_NestedZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedZKeyControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedZKeyControl.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedZKeyControl = {
    MainMap_NestedZKeyControl_Entry,
    MainMap_NestedZKeyControl_Exit,
    MainMap_NestedZKeyControl_keydown,
    MainMap_NestedZKeyControl_keyup,
    MainMap_NestedZKeyControl_Default,
    5, "MainMap_NestedZKeyControl"
};

void MainMap_NestedSlashControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_NestedSlashControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_NestedSlashControl_keydown
static void MainMap_NestedSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedSlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSlashControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSlashControl.keydown(event)\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSlashControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSlashControl.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_NestedSlashControl_keyup
static void MainMap_NestedSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_NestedSlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSlashControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_NestedSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_NestedSlashControl.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedSlashControl = {
    MainMap_NestedSlashControl_Entry,
    MainMap_NestedSlashControl_Exit,
    MainMap_NestedSlashControl_keydown,
    MainMap_NestedSlashControl_keyup,
    MainMap_NestedSlashControl_Default,
    6, "MainMap_NestedSlashControl"
};

#undef MainMap_PreSpace_keydown
static void MainMap_PreSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreSpace)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        setState(fsm, &MainMap_Space);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
        pushState(fsm, &MainMap_PreSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        setState(fsm, &MainMap_Space);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
        pushState(fsm, &MainMap_PreZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        setState(fsm, &MainMap_Space);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_space_mode(ctxt, True);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keydown(event)\n");
        }
        setState(fsm, &MainMap_Space);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
}

#undef MainMap_PreSpace_keyup
static void MainMap_PreSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreSpace)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_space(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        setState(fsm, &MainMap_PostSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSpace.keyup(event)\n");
        }
        setState(fsm, &MainMap_PostSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreSpace = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreSpace_keydown,
    MainMap_PreSpace_keyup,
    MainMap_PreSpace_Default,
    7, "MainMap_PreSpace"
};

void MainMap_Space_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, True);
}

void MainMap_Space_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, False);
}

#undef MainMap_Space_keydown
static void MainMap_Space_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Space)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keydown(event)\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Space_keyup
static void MainMap_Space_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_Space)\n");
    }
    if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_Space.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_Space.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Space = {
    MainMap_Space_Entry,
    MainMap_Space_Exit,
    MainMap_Space_keydown,
    MainMap_Space_keyup,
    MainMap_Space_Default,
    8, "MainMap_Space"
};

#undef MainMap_PreZKeyControl_keydown
static void MainMap_PreZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_ZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_ZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
        pushState(fsm, &MainMap_PreSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_buffer(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreZKeyControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_SemiZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
}

#undef MainMap_PreZKeyControl_keyup
static void MainMap_PreZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreZKeyControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreZKeyControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreZKeyControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreZKeyControl_keydown,
    MainMap_PreZKeyControl_keyup,
    MainMap_PreZKeyControl_Default,
    9, "MainMap_PreZKeyControl"
};

#undef MainMap_PreSlashControl_keydown
static void MainMap_PreSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreSlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_SlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_SlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
        pushState(fsm, &MainMap_PreSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_buffer(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSlashControl.keydown(event)\n");
        }
        setState(fsm, &MainMap_SemiSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
}

#undef MainMap_PreSlashControl_keyup
static void MainMap_PreSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_PreSlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSlashControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_PreSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_PreSlashControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreSlashControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreSlashControl_keydown,
    MainMap_PreSlashControl_keyup,
    MainMap_PreSlashControl_Default,
    10, "MainMap_PreSlashControl"
};

#undef MainMap_SemiZKeyControl_keydown
static void MainMap_SemiZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SemiZKeyControl)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiZKeyControl.keydown(event)\n");
    }
    clearState(fsm);
    Turnstile_control_mode(ctxt, True);
    Turnstile_flush(ctxt);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiZKeyControl.keydown(event)\n");
    }
    setState(fsm, &MainMap_ZKeyControl);
    if (getDebugFlag(fsm) != 0) {
        TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
    }
    ENTRY_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
    }
}

#undef MainMap_SemiZKeyControl_keyup
static void MainMap_SemiZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SemiZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_control_mode(ctxt, True);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiZKeyControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_ZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
}

const struct TurnstileState MainMap_SemiZKeyControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_SemiZKeyControl_keydown,
    MainMap_SemiZKeyControl_keyup,
    MainMap_SemiZKeyControl_Default,
    11, "MainMap_SemiZKeyControl"
};

#undef MainMap_SemiSlashControl_keydown
static void MainMap_SemiSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SemiSlashControl)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiSlashControl.keydown(event)\n");
    }
    clearState(fsm);
    Turnstile_control_mode(ctxt, True);
    Turnstile_flush(ctxt);
    Turnstile_emit(ctxt, event);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiSlashControl.keydown(event)\n");
    }
    setState(fsm, &MainMap_SlashControl);
    if (getDebugFlag(fsm) != 0) {
        TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
    }
    ENTRY_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
    }
}

#undef MainMap_SemiSlashControl_keyup
static void MainMap_SemiSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SemiSlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_control_mode(ctxt, True);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SemiSlashControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_SlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
}

const struct TurnstileState MainMap_SemiSlashControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_SemiSlashControl_keydown,
    MainMap_SemiSlashControl_keyup,
    MainMap_SemiSlashControl_Default,
    12, "MainMap_SemiSlashControl"
};

void MainMap_ZKeyControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_ZKeyControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_ZKeyControl_keydown
static void MainMap_ZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_ZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
        pushState(fsm, &MainMap_PreSpace);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_ZKeyControl_keyup
static void MainMap_ZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_ZKeyControl)\n");
    }
    if ( event.is_z ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedZKeyControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_ZKeyControl.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_ZKeyControl = {
    MainMap_ZKeyControl_Entry,
    MainMap_ZKeyControl_Exit,
    MainMap_ZKeyControl_keydown,
    MainMap_ZKeyControl_keyup,
    MainMap_ZKeyControl_Default,
    13, "MainMap_ZKeyControl"
};

void MainMap_SlashControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_SlashControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_SlashControl_keydown
static void MainMap_SlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SlashControl.keydown(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SlashControl.keydown(event)\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SlashControl.keydown(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SlashControl.keydown(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

#undef MainMap_SlashControl_keyup
static void MainMap_SlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : MainMap_SlashControl)\n");
    }
    if ( event.is_slash ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        popState(fsm);
    }
    else if ( event.is_space ) {
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE EXIT     : EXIT_STATE(getState(fsm))\n");
        }
        EXIT_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER EXIT      : EXIT_STATE(getState(fsm))\n");
        }
        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        /* No actions. */
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        setState(fsm, &MainMap_NestedSlashControl);
        if (getDebugFlag(fsm) != 0) {
            TRACE("BEFORE ENTRY    : ENTRY_STATE(getState(fsm))\n");
        }
        ENTRY_STATE(getState(fsm));
        if (getDebugFlag(fsm) != 0) {
            TRACE("AFTER ENTRY     : ENTRY_STATE(getState(fsm))\n");
        }
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        if (getDebugFlag(fsm) != 0) {
            TRACE("ENTER TRANSITION: MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        clearState(fsm);
        Turnstile_emit(ctxt, event);
        if (getDebugFlag(fsm) != 0) {
            TRACE("EXIT TRANSITION : MainMap_&MainMap_SlashControl.keyup(event)\n");
        }
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_SlashControl = {
    MainMap_SlashControl_Entry,
    MainMap_SlashControl_Exit,
    MainMap_SlashControl_keydown,
    MainMap_SlashControl_keyup,
    MainMap_SlashControl_Default,
    14, "MainMap_SlashControl"
};

#ifdef NO_SATSUKI_SM_MACRO
void satsukiContext_Init(struct satsukiContext *const fsm, struct Turnstile *const owner)
{
    FSM_INIT(fsm, &MainMap_Normal);
    fsm->_owner = owner;
}

void satsukiContext_EnterStartState(struct satsukiContext *const fsm)
{
    ENTRY_STATE(getState(fsm));
}

void satsukiContext_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    const struct TurnstileState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "keydown");
    state->keydown(fsm, event);
    setTransition(fsm, NULL);
}

void satsukiContext_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    const struct TurnstileState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "keyup");
    state->keyup(fsm, event);
    setTransition(fsm, NULL);
}
#endif

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
