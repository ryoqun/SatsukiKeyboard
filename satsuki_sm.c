/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : satsuki.sm
 */

#include "engine.h"
#include "satsuki_sm.h"

#define getOwner(fsm) (fsm)->_owner

#define ENTRY_STATE(state) \
    if ((state)->Entry != NULL) { \
        (state)->Entry(fsm); \
    }

#define EXIT_STATE(state) \
    if ((state)->Exit != NULL) { \
        (state)->Exit(fsm); \
    }

static void TurnstileState_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    getState(fsm)->Default(fsm);
}

static void TurnstileState_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    getState(fsm)->Default(fsm);
}

static void TurnstileState_Default(struct satsukiContext *const fsm)
{
    State_Default(fsm);
}

#define MainMap_Normal_keydown TurnstileState_keydown
#define MainMap_Normal_keyup TurnstileState_keyup
#define MainMap_Normal_Default TurnstileState_Default
#define MainMap_Shift_keydown TurnstileState_keydown
#define MainMap_Shift_keyup TurnstileState_keyup
#define MainMap_Shift_Default TurnstileState_Default
#define MainMap_Tenkey_keydown TurnstileState_keydown
#define MainMap_Tenkey_keyup TurnstileState_keyup
#define MainMap_Tenkey_Default TurnstileState_Default
#define MainMap_PostSpace_keydown TurnstileState_keydown
#define MainMap_PostSpace_keyup TurnstileState_keyup
#define MainMap_PostSpace_Default TurnstileState_Default
#define MainMap_NestedSpace_keydown TurnstileState_keydown
#define MainMap_NestedSpace_keyup TurnstileState_keyup
#define MainMap_NestedSpace_Default TurnstileState_Default
#define MainMap_NestedZKeyControl_keydown TurnstileState_keydown
#define MainMap_NestedZKeyControl_keyup TurnstileState_keyup
#define MainMap_NestedZKeyControl_Default TurnstileState_Default
#define MainMap_NestedSlashControl_keydown TurnstileState_keydown
#define MainMap_NestedSlashControl_keyup TurnstileState_keyup
#define MainMap_NestedSlashControl_Default TurnstileState_Default
#define MainMap_PreSpace_keydown TurnstileState_keydown
#define MainMap_PreSpace_keyup TurnstileState_keyup
#define MainMap_PreSpace_Default TurnstileState_Default
#define MainMap_Space_keydown TurnstileState_keydown
#define MainMap_Space_keyup TurnstileState_keyup
#define MainMap_Space_Default TurnstileState_Default
#define MainMap_PreZKeyControl_keydown TurnstileState_keydown
#define MainMap_PreZKeyControl_keyup TurnstileState_keyup
#define MainMap_PreZKeyControl_Default TurnstileState_Default
#define MainMap_PreSlashControl_keydown TurnstileState_keydown
#define MainMap_PreSlashControl_keyup TurnstileState_keyup
#define MainMap_PreSlashControl_Default TurnstileState_Default
#define MainMap_SemiZKeyControl_keydown TurnstileState_keydown
#define MainMap_SemiZKeyControl_keyup TurnstileState_keyup
#define MainMap_SemiZKeyControl_Default TurnstileState_Default
#define MainMap_SemiSlashControl_keydown TurnstileState_keydown
#define MainMap_SemiSlashControl_keyup TurnstileState_keyup
#define MainMap_SemiSlashControl_Default TurnstileState_Default
#define MainMap_ZKeyControl_keydown TurnstileState_keydown
#define MainMap_ZKeyControl_keyup TurnstileState_keyup
#define MainMap_ZKeyControl_Default TurnstileState_Default
#define MainMap_SlashControl_keydown TurnstileState_keydown
#define MainMap_SlashControl_keyup TurnstileState_keyup
#define MainMap_SlashControl_Default TurnstileState_Default
#define MainMap_DefaultState_keydown TurnstileState_keydown
#define MainMap_DefaultState_keyup TurnstileState_keyup

#undef MainMap_Normal_keydown
static void MainMap_Normal_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreSpace);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_slash ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreSlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_z ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_shift ) {
        /* No actions. */
        pushState(fsm, &MainMap_Shift);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_tenkey ) {
        /* No actions. */
        pushState(fsm, &MainMap_Tenkey);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Normal_keyup
static void MainMap_Normal_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    clearState(fsm);
    Turnstile_emit(ctxt, event);
    setState(fsm, EndStateName);
}

const struct TurnstileState MainMap_Normal = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_Normal_keydown,
    MainMap_Normal_keyup,
    MainMap_Normal_Default,
    0
};

void MainMap_Shift_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_shift_mode(ctxt, True);
}

void MainMap_Shift_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_shift_mode(ctxt, False);
}

#undef MainMap_Shift_keydown
static void MainMap_Shift_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreSpace);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_tenkey ) {
        /* No actions. */
        pushState(fsm, &MainMap_Tenkey);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Shift_keyup
static void MainMap_Shift_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_shift ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Shift = {
    MainMap_Shift_Entry,
    MainMap_Shift_Exit,
    MainMap_Shift_keydown,
    MainMap_Shift_keyup,
    MainMap_Shift_Default,
    1
};

void MainMap_Tenkey_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_tenkey_mode(ctxt, True);
}

void MainMap_Tenkey_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_tenkey_mode(ctxt, False);
}

#undef MainMap_Tenkey_keydown
static void MainMap_Tenkey_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    clearState(fsm);
    Turnstile_emit(ctxt, event);
    setState(fsm, EndStateName);
}

#undef MainMap_Tenkey_keyup
static void MainMap_Tenkey_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_tenkey ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Tenkey = {
    MainMap_Tenkey_Entry,
    MainMap_Tenkey_Exit,
    MainMap_Tenkey_keydown,
    MainMap_Tenkey_keyup,
    MainMap_Tenkey_Default,
    2
};

#undef MainMap_PostSpace_keydown
static void MainMap_PostSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    clearState(fsm);
    Turnstile_emit(ctxt, event);
    setState(fsm, EndStateName);
}

#undef MainMap_PostSpace_keyup
static void MainMap_PostSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_PostSpace = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PostSpace_keydown,
    MainMap_PostSpace_keyup,
    MainMap_PostSpace_Default,
    3
};

void MainMap_NestedSpace_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, True);
}

void MainMap_NestedSpace_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, False);
}

#undef MainMap_NestedSpace_keydown
static void MainMap_NestedSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);
    const struct TurnstileState* EndStateName = getState(fsm);

    clearState(fsm);
    Turnstile_emit(ctxt, event);
    setState(fsm, EndStateName);
}

#undef MainMap_NestedSpace_keyup
static void MainMap_NestedSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedSpace = {
    MainMap_NestedSpace_Entry,
    MainMap_NestedSpace_Exit,
    MainMap_NestedSpace_keydown,
    MainMap_NestedSpace_keyup,
    MainMap_NestedSpace_Default,
    4
};

void MainMap_NestedZKeyControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_NestedZKeyControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_NestedZKeyControl_keydown
static void MainMap_NestedZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        /* No actions. */
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_NestedZKeyControl_keyup
static void MainMap_NestedZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedZKeyControl = {
    MainMap_NestedZKeyControl_Entry,
    MainMap_NestedZKeyControl_Exit,
    MainMap_NestedZKeyControl_keydown,
    MainMap_NestedZKeyControl_keyup,
    MainMap_NestedZKeyControl_Default,
    5
};

void MainMap_NestedSlashControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_NestedSlashControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_NestedSlashControl_keydown
static void MainMap_NestedSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        /* No actions. */
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_NestedSlashControl_keyup
static void MainMap_NestedSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_pop_state(ctxt);
        popState(fsm);
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_NestedSlashControl = {
    MainMap_NestedSlashControl_Entry,
    MainMap_NestedSlashControl_Exit,
    MainMap_NestedSlashControl_keydown,
    MainMap_NestedSlashControl_keyup,
    MainMap_NestedSlashControl_Default,
    6
};

#undef MainMap_PreSpace_keydown
static void MainMap_PreSpace_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_Space);
        ENTRY_STATE(getState(fsm));
        pushState(fsm, &MainMap_PreSlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_Space);
        ENTRY_STATE(getState(fsm));
        pushState(fsm, &MainMap_PreZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_Space);
        ENTRY_STATE(getState(fsm));
    }
    else {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_space_mode(ctxt, True);
        Turnstile_emit(ctxt, event);
        setState(fsm, &MainMap_Space);
        ENTRY_STATE(getState(fsm));
    }
}

#undef MainMap_PreSpace_keyup
static void MainMap_PreSpace_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_space(ctxt);
        popState(fsm);
    }
    else if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        setState(fsm, &MainMap_PostSpace);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        setState(fsm, &MainMap_PostSpace);
        ENTRY_STATE(getState(fsm));
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreSpace = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreSpace_keydown,
    MainMap_PreSpace_keyup,
    MainMap_PreSpace_Default,
    7
};

void MainMap_Space_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, True);
}

void MainMap_Space_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_space_mode(ctxt, False);
}

#undef MainMap_Space_keydown
static void MainMap_Space_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreSlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_z ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_space ) {
        /* No actions. */
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_Space_keyup
static void MainMap_Space_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        popState(fsm);
    }
    else if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedSpace);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedSpace);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_Space = {
    MainMap_Space_Entry,
    MainMap_Space_Exit,
    MainMap_Space_keydown,
    MainMap_Space_keyup,
    MainMap_Space_Default,
    8
};

#undef MainMap_PreZKeyControl_keydown
static void MainMap_PreZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_ZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_ZKeyControl);
        ENTRY_STATE(getState(fsm));
        pushState(fsm, &MainMap_PreSpace);
        ENTRY_STATE(getState(fsm));
    }
    else {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_buffer(ctxt, event);
        setState(fsm, &MainMap_SemiZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
}

#undef MainMap_PreZKeyControl_keyup
static void MainMap_PreZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        setState(fsm, &MainMap_NestedZKeyControl);
        ENTRY_STATE(getState(fsm));
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreZKeyControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreZKeyControl_keydown,
    MainMap_PreZKeyControl_keyup,
    MainMap_PreZKeyControl_Default,
    9
};

#undef MainMap_PreSlashControl_keydown
static void MainMap_PreSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_SlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_SlashControl);
        ENTRY_STATE(getState(fsm));
        pushState(fsm, &MainMap_PreSpace);
        ENTRY_STATE(getState(fsm));
    }
    else {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_buffer(ctxt, event);
        setState(fsm, &MainMap_SemiSlashControl);
        ENTRY_STATE(getState(fsm));
    }
}

#undef MainMap_PreSlashControl_keyup
static void MainMap_PreSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        setState(fsm, &MainMap_NestedSlashControl);
        ENTRY_STATE(getState(fsm));
    }    else {
        MainMap_DefaultState_keyup(fsm, event);
    }
}

const struct TurnstileState MainMap_PreSlashControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_PreSlashControl_keydown,
    MainMap_PreSlashControl_keyup,
    MainMap_PreSlashControl_Default,
    10
};

#undef MainMap_SemiZKeyControl_keydown
static void MainMap_SemiZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    EXIT_STATE(getState(fsm));
    clearState(fsm);
    Turnstile_control_mode(ctxt, True);
    Turnstile_flush(ctxt);
    Turnstile_emit(ctxt, event);
    setState(fsm, &MainMap_ZKeyControl);
    ENTRY_STATE(getState(fsm));
}

#undef MainMap_SemiZKeyControl_keyup
static void MainMap_SemiZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_z(ctxt);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_control_mode(ctxt, True);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        setState(fsm, &MainMap_ZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
}

const struct TurnstileState MainMap_SemiZKeyControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_SemiZKeyControl_keydown,
    MainMap_SemiZKeyControl_keyup,
    MainMap_SemiZKeyControl_Default,
    11
};

#undef MainMap_SemiSlashControl_keydown
static void MainMap_SemiSlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    EXIT_STATE(getState(fsm));
    clearState(fsm);
    Turnstile_control_mode(ctxt, True);
    Turnstile_flush(ctxt);
    Turnstile_emit(ctxt, event);
    setState(fsm, &MainMap_SlashControl);
    ENTRY_STATE(getState(fsm));
}

#undef MainMap_SemiSlashControl_keyup
static void MainMap_SemiSlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_emit_slash(ctxt);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedSlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else {
        EXIT_STATE(getState(fsm));
        clearState(fsm);
        Turnstile_control_mode(ctxt, True);
        Turnstile_flush(ctxt);
        Turnstile_emit(ctxt, event);
        setState(fsm, &MainMap_SlashControl);
        ENTRY_STATE(getState(fsm));
    }
}

const struct TurnstileState MainMap_SemiSlashControl = {
    NULL, /* Entry */
    NULL, /* Exit */
    MainMap_SemiSlashControl_keydown,
    MainMap_SemiSlashControl_keyup,
    MainMap_SemiSlashControl_Default,
    12
};

void MainMap_ZKeyControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_ZKeyControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_ZKeyControl_keydown
static void MainMap_ZKeyControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        /* No actions. */
    }
    else if ( event.is_space ) {
        /* No actions. */
        pushState(fsm, &MainMap_PreSpace);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_ZKeyControl_keyup
static void MainMap_ZKeyControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_z ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedZKeyControl);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_ZKeyControl = {
    MainMap_ZKeyControl_Entry,
    MainMap_ZKeyControl_Exit,
    MainMap_ZKeyControl_keydown,
    MainMap_ZKeyControl_keyup,
    MainMap_ZKeyControl_Default,
    13
};

void MainMap_SlashControl_Entry(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, True);
}

void MainMap_SlashControl_Exit(struct satsukiContext *const fsm)
{
    struct Turnstile *ctxt = getOwner(fsm);

    Turnstile_control_mode(ctxt, False);
}

#undef MainMap_SlashControl_keydown
static void MainMap_SlashControl_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        /* No actions. */
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

#undef MainMap_SlashControl_keyup
static void MainMap_SlashControl_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    struct Turnstile *ctxt = getOwner(fsm);

    if ( event.is_slash ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        popState(fsm);
    }
    else if ( event.is_space ) {
        EXIT_STATE(getState(fsm));
        /* No actions. */
        setState(fsm, &MainMap_NestedSlashControl);
        ENTRY_STATE(getState(fsm));
    }
    else {
        const struct TurnstileState* EndStateName = getState(fsm);

        clearState(fsm);
        Turnstile_emit(ctxt, event);
        setState(fsm, EndStateName);
    }
}

const struct TurnstileState MainMap_SlashControl = {
    MainMap_SlashControl_Entry,
    MainMap_SlashControl_Exit,
    MainMap_SlashControl_keydown,
    MainMap_SlashControl_keyup,
    MainMap_SlashControl_Default,
    14
};

#ifdef NO_SATSUKI_SM_MACRO
void satsukiContext_Init(struct satsukiContext *const fsm, struct Turnstile *const owner)
{
    FSM_INIT(fsm, &MainMap_Normal);
    fsm->_owner = owner;
}

void satsukiContext_EnterStartState(struct satsukiContext *const fsm)
{
    ENTRY_STATE(getState(fsm));
}

void satsukiContext_keydown(struct satsukiContext *const fsm, KeyEvent event)
{
    const struct TurnstileState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "keydown");
    state->keydown(fsm, event);
    setTransition(fsm, NULL);
}

void satsukiContext_keyup(struct satsukiContext *const fsm, KeyEvent event)
{
    const struct TurnstileState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "keyup");
    state->keyup(fsm, event);
    setTransition(fsm, NULL);
}
#endif

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
